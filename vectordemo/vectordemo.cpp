#include <iostream>
#include <vector>

//вектор - это часть системы коллекций stl
//
// vector и array реализуют модель хранения: линейный массив
// vector - решение по умолчанию для любой коллекции данных в программе
//          испольовать другие требуется только тогда когда есть особые
//          требования к алгоритмам которые будут взаимодействовать 
//          с коллекцией
// 
// требования для работы:
//    1.  для того чтобы создать объект вектора требуется указать
//      полный тип в качестве типа для работы
//    2. для работы основных методов класса тип для работы 
//       должен содержать:
//          конструктор по умолчанию
//          конструктор копирования
//          присваивание копированием
//          деструктор
//    3. для работы методов заполнения требуется наличие 
//       конструктора с параметрами
//

class Demo {
public:
    Demo():a(-18)
    { std::cout << "Def constructor\n"; }

    Demo(int val):a(val)
    { std::cout << "Param constructor\n"; }

    Demo(const Demo &other):a(other.a)
    { std::cout << "Copy constructor\n"; }

    ~Demo()
    { std::cout << "Def destructor\n"; }

private:
    int a;
};


int main()
{
    //1.
    std::vector<int> arr;  //вектор от полного типа int
    //std::vector<void> arr2;// вектор от неполного типа void
    //первая строчка пройдёт компиляцию, а вторая сломает программу
    //такая же история произойдёт если вы попробуете создать вектор
    //от абстрактного класса

    //2.
    std::vector<Demo> arr3(3);
    //при создании вектора в его конструктор можно передать число
    //это создат вектор в котором будет такое число пустых элементов
    //данный конструктор будет работать только если есть конструктор 
    // по умолчанию у хранимого класса

    arr3.reserve(1000);
    //метод резервирует под использование память на столько элементов 
    // сколько указали но не создаёт их сразу
    // При прочих равных правильнее создать пустой вектор и 
    // зарезервировать память а не создавать вектор пустышек конструктором

    arr3.resize(10);
    // изменяет размер хранимых элементов(их количество)
    // если новый размер больше то в конец массива добавляются пустышки
    // если новый размер меньше текущего количества то все что не 
    // поместились уничтожаются

    arr3.resize(5);

    arr3.shrink_to_fit();
    //не изменяет количество хранимых элементов но освобождает 
    // неиспользуемый коллекцией кусок памяти

    //push_back emplace_back
    // для обоих требуется чтобы был конструктор с параметрами
    // для работы push_back требуется дополнительно конструктор 
    // копирования
    arr3.push_back(Demo(4));
    arr3.emplace_back(6);
    //push_back для классов с конструктором от 2х параметров и более
    //не сможет вызваться если напрямую не указать конструктор
    //emplace всегда принимаетнабор аргументов конструктора и не вызывает 
    // конструкторов копирования

    arr3.pop_back();//удаляет самый последний элемент массива
    //вместительность не трогает, размер уменьшается

    auto it = arr3.begin(); //медот даёт итератор на начало коллекции
    //they keep location of first element in collection
    // при необходимости  можно сместить его положение с помощью 
    // операторов ++ -- + - += -= по правилам арифметики указателей

    arr3.erase(it+2);
    it--; it++;
    // му удалили элемент на две ячейки отстаящий от начала

    // размещение элементов на нужной позиции
    arr3.insert(it+2,Demo(8));
    arr3.emplace(arr3.begin()+3, 6);

    //insert и push_back применяются когда есть образец
    //emplace и emplace_back применяются когда нужно создать элемент

    return 0;
}